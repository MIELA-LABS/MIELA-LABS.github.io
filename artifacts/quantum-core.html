<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MIELA LABS | QUANTUM CORE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&display=swap');

    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #050505; /* Derin siyah */
        font-family: 'Rajdhani', sans-serif;
    }

    #canvas-container {
        width: 100vw;
        height: 100vh;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
    }

    .ui {
        position: absolute;
        bottom: 40px;
        left: 40px;
        z-index: 2;
        color: rgba(255, 255, 255, 0.8);
        pointer-events: none; /* Mouse canvas'a geçsin diye */
        text-transform: uppercase;
    }

    h1 {
        font-size: 3rem;
        margin: 0;
        letter-spacing: 5px;
        background: linear-gradient(90deg, #00ffff, #ff00ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }

    p {
        font-size: 1rem;
        margin: 5px 0;
        letter-spacing: 2px;
        font-weight: 300;
    }

    .instruction {
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.4);
        margin-top: 15px;
    }
</style>

<!-- Vertex Shader (Parçacıkların Konumu ve Hareketi) -->
<script type="x-shader/x-vertex" id="vertexshader">
  uniform float uTime;
  uniform vec2 uMouse;
  attribute float aScale;
  attribute vec3 aRandomness;
  varying vec3 vColor;

  // Simplex Noise Fonksiyonu (Organik hareket için)
  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
  vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

  float snoise(vec3 v) {
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 = v - i + dot(i, C.xxx) ;
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;
    i = mod289(i);
    vec4 p = permute( permute( permute(
              i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
    float n_ = 0.142857142857;
    vec3  ns = n_ * D.wyz - D.xzx;
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );
    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    return 42.0 * dot( p0, x0 ); // Basit noise dönüşü
  }

  void main() {
    vec3 newPos = position;
    
    // Noise ile dalgalanma efekti
    float noiseVal = snoise(vec3(position.x * 0.5 + uTime * 0.2, position.y * 0.5 + uTime * 0.3, uTime * 0.1));
    
    // Mouse etkileşimi (Basit bir uzaklaşma efekti)
    // Gerçek 3D mouse pozisyonu yerine basit bir distorsiyon kullanıyoruz
    // Mouse koordinatlarını -1 ile 1 arasına normalize ettiğimiz için direkt kullanabiliriz
    // Ancak burada basitlik adına mouse etkisini noise ile karıştırıyoruz
    
    float mouseDist = distance(vec2(newPos.x, newPos.y), uMouse * 5.0); // Mouse etkisini genişlet
    float mouseEffect = smoothstep(3.0, 0.0, mouseDist) * 2.0;

    newPos += normal * (noiseVal * (1.0 + mouseEffect));

    vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
    gl_Position = projectionMatrix * mvPosition;

    // Boyutlandırma (Derinlik algısı için)
    gl_PointSize = (10.0 * aScale + (mouseEffect * 10.0)) * (1.0 / -mvPosition.z);

    // Renk hesaplama (Pozisyona ve zamana göre)
    // Cyan ve Magenta karışımı
    vec3 color1 = vec3(0.0, 1.0, 1.0); // Cyan
    vec3 color2 = vec3(1.0, 0.0, 1.0); // Magenta
    
    float mixVal = smoothstep(-1.0, 1.0, noiseVal + sin(uTime));
    vColor = mix(color1, color2, mixVal);
    
    // Mouse yakınsa beyaza dönsün
    vColor = mix(vColor, vec3(1.0), mouseEffect);
  }
</script>

<!-- Fragment Shader (Parçacıkların Rengi ve Şekli) -->
<script type="x-shader/x-fragment" id="fragmentshader">
  varying vec3 vColor;

  void main() {
    // Dairesel parçacık şekli oluşturma
    float r = distance(gl_PointCoord, vec2(0.5));
    if (r > 0.5) discard;

    // Yumuşak kenarlar (Glow etkisi için)
    float glow = 1.0 - (r * 2.0);
    glow = pow(glow, 1.5);

    gl_FragColor = vec4(vColor, glow);
  }
</script>

<!-- Three.js Imports -->
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="ui">
        <h1>QUANTUM CORE</h1>
        <p>Interactive Generative System</p>
        <p class="instruction">Drag to Rotate &bull; Hover to Disturb</p>
    </div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// --- YAPILANDIRMA ---
const CONFIG = {
  particleCount: 30000, // Parçacık sayısı
  particleSize: 2.0,
  bloomStrength: 1.5,
  bloomRadius: 0.4,
  bloomThreshold: 0,
  rotationSpeed: 0.001
};

// --- SAHNE KURULUMU ---
const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();
// Arka plana hafif bir sis ekleyelim
scene.fog = new THREE.FogExp2(0x050505, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.z = 6;
camera.position.y = 1;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ReinhardToneMapping;
container.appendChild(renderer.domElement);

// --- KONTROLLER ---
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.enableZoom = true;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.5;

// --- GEOMETRİ VE PARÇACIKLAR ---
const geometry = new THREE.BufferGeometry();
const positions = [];
const scales = [];
const randomness = [];

const radius = 2.5;

for (let i = 0; i < CONFIG.particleCount; i++) {
  // Küresel koordinatlarda rastgele noktalar
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos((Math.random() * 2) - 1);
  
  const x = radius * Math.sin(phi) * Math.cos(theta);
  const y = radius * Math.sin(phi) * Math.sin(theta);
  const z = radius * Math.cos(phi);

  positions.push(x, y, z);
  
  // Her parçacık için rastgele boyut
  scales.push(Math.random());
  
  // Rastgelelik vektörü
  randomness.push(Math.random(), Math.random(), Math.random());
}

geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
geometry.setAttribute('aScale', new THREE.Float32BufferAttribute(scales, 1));
geometry.setAttribute('aRandomness', new THREE.Float32BufferAttribute(randomness, 3));

// --- SHADER MATERIAL ---
const material = new THREE.ShaderMaterial({
  vertexShader: document.getElementById('vertexshader').textContent,
  fragmentShader: document.getElementById('fragmentshader').textContent,
  uniforms: {
    uTime: { value: 0 },
    uMouse: { value: new THREE.Vector2(0, 0) }
  },
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending // Işıkların üst üste binince parlaması için
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

// --- POST PROCESSING (BLOOM) ---
const renderScene = new RenderPass(scene, camera);

const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  CONFIG.bloomStrength,
  CONFIG.bloomRadius,
  CONFIG.bloomThreshold
);

const composer = new EffectComposer(renderer);
composer.addPass(renderScene);
composer.addPass(bloomPass);

// --- EVENT LISTENERS ---
const mouse = new THREE.Vector2();

window.addEventListener('mousemove', (event) => {
  // Mouse koordinatlarını normalize et (-1 ile 1 arası)
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  // Shader'a gönder
  material.uniforms.uMouse.value = mouse;
});

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});

// --- ANIMATION LOOP ---
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);

  const elapsedTime = clock.getElapsedTime();

  // Shader zamanını güncelle
  material.uniforms.uTime.value = elapsedTime;

  // Hafif genel dönüş
  particles.rotation.y = elapsedTime * 0.05;
  particles.rotation.z = elapsedTime * 0.02;

  controls.update();
  
  // Renderer yerine Composer kullanıyoruz (Bloom için)
  composer.render();
}

animate();
</script>
</body>
</html>